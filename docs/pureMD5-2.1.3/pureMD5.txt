-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell-only implementation of the MD5 digest (hash) algorithm.
--   
--   A Haskell-only implementation of the MD5 digest (hash) algorithm. This
--   now supports the crypto-api class interface.
@package pureMD5
@version 2.1.3


-- | It is suggested you use the 'crypto-api' class-based interface to
--   access the MD5 algorithm. Either rely on type inference or provide an
--   explicit type:
--   
--   <pre>
--   hashFileStrict = liftM hash' . B.readFile
--   hashFileLazyBS = liftM hash . B.readFile
--   </pre>
module Data.Digest.Pure.MD5

-- | The type for final results.
data MD5Context

-- | After finalizing a context, using md5Finalize, a new type is returned
--   to prevent 're-finalizing' the structure.
data MD5Digest

-- | The initial context to use when calling md5Update for the first time
md5InitialContext :: MD5Context

-- | Processes a lazy ByteString and returns the md5 digest. This is
--   probably what you want.
md5 :: ByteString -> MD5Digest

-- | Alters the MD5Context with a partial digest of the data.
--   
--   The input bytestring MUST be a multiple of the blockSize or bad things
--   can happen (incorrect digest results)!
md5Update :: MD5Context -> ByteString -> MD5Context

-- | Closes an MD5 context, thus producing the digest.
md5Finalize :: MD5Context -> ByteString -> MD5Digest

-- | The raw bytes of an <a>MD5Digest</a>. It is always 16 bytes long.
--   
--   You can also use the <a>Binary</a> or <a>Serialize</a> instances to
--   output the raw bytes. Alternatively you can use <a>show</a> to prodce
--   the standard hex representation.
md5DigestBytes :: MD5Digest -> ByteString

-- | The Hash class is intended as the generic interface targeted by
--   maintainers of Haskell digest implementations. Using this generic
--   interface, higher level functions such as <a>hash</a> and <a>hash'</a>
--   provide a useful API for comsumers of hash implementations.
--   
--   Any instantiated implementation must handle unaligned data.
--   
--   Minimum complete definition: <a>outputLength</a>, <a>blockLength</a>,
--   <a>initialCtx</a>, <a>updateCtx</a>, and <a>finalize</a>.
class (Serialize d, Eq d, Ord d) => Hash ctx d | d -> ctx, ctx -> d
outputLength :: Tagged * d BitLength
blockLength :: Tagged * d BitLength
initialCtx :: ctx
updateCtx :: ctx -> ByteString -> ctx
finalize :: ctx -> ByteString -> d

-- | Hash a lazy ByteString, creating a digest
hash :: ByteString -> d

-- | Hash a strict ByteString, creating a digest
hash' :: ByteString -> d
instance GHC.Classes.Ord Data.Digest.Pure.MD5.MD5Digest
instance GHC.Classes.Eq Data.Digest.Pure.MD5.MD5Digest
instance GHC.Classes.Eq Data.Digest.Pure.MD5.MD5Partial
instance GHC.Classes.Ord Data.Digest.Pure.MD5.MD5Partial
instance GHC.Show.Show Data.Digest.Pure.MD5.MD5Digest
instance GHC.Show.Show Data.Digest.Pure.MD5.MD5Partial
instance Data.Binary.Class.Binary Data.Digest.Pure.MD5.MD5Digest
instance Data.Binary.Class.Binary Data.Digest.Pure.MD5.MD5Context
instance Data.Binary.Class.Binary Data.Digest.Pure.MD5.MD5Partial
instance Data.Serialize.Serialize Data.Digest.Pure.MD5.MD5Digest
instance Data.Serialize.Serialize Data.Digest.Pure.MD5.MD5Context
instance Data.Serialize.Serialize Data.Digest.Pure.MD5.MD5Partial
instance Crypto.Classes.Hash Data.Digest.Pure.MD5.MD5Context Data.Digest.Pure.MD5.MD5Digest
