-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic cryptography cipher types
--   
--   Generic cryptography cipher types
@package crypto-cipher-types
@version 0.0.9


-- | mutable and unsafe interface for Block ciphers. export a BlockCipherIO
--   class
module Crypto.Cipher.Types.Unsafe

-- | Symmetric block cipher class, mutable API
class BlockCipher cipher => BlockCipherIO cipher where cbcEncryptMutable = cbcEncryptGeneric cbcDecryptMutable = cbcDecryptGeneric

-- | Encrypt using the ECB mode.
--   
--   input need to be a multiple of the blocksize
ecbEncryptMutable :: BlockCipherIO cipher => cipher -> PtrDest -> PtrSource -> BufferLength -> IO ()

-- | Decrypt using the ECB mode.
--   
--   input need to be a multiple of the blocksize
ecbDecryptMutable :: BlockCipherIO cipher => cipher -> PtrDest -> PtrSource -> BufferLength -> IO ()

-- | encrypt using the CBC mode.
--   
--   input need to be a multiple of the blocksize
cbcEncryptMutable :: BlockCipherIO cipher => cipher -> PtrIV -> PtrDest -> PtrSource -> BufferLength -> IO ()

-- | decrypt using the CBC mode.
--   
--   input need to be a multiple of the blocksize
cbcDecryptMutable :: BlockCipherIO cipher => cipher -> PtrIV -> PtrDest -> PtrSource -> BufferLength -> IO ()

-- | Length of the pointed data
type BufferLength = Word32

-- | pointer to the destination data
type PtrDest = Ptr Word8

-- | pointer to the source data
type PtrSource = Ptr Word8

-- | pointer to the IV data
type PtrIV = Ptr Word8

-- | Helper to use a purer interface
onBlock :: BlockCipherIO cipher => cipher -> (ByteString -> ByteString) -> PtrDest -> PtrSource -> BufferLength -> IO ()


-- | symmetric cipher basic types
module Crypto.Cipher.Types

-- | Symmetric cipher class.
class Cipher cipher

-- | Initialize a cipher context from a key
cipherInit :: Cipher cipher => Key cipher -> cipher

-- | Cipher name
cipherName :: Cipher cipher => cipher -> String

-- | return the size of the key required for this cipher. Some cipher
--   accept any size for key
cipherKeySize :: Cipher cipher => cipher -> KeySizeSpecifier

-- | Symmetric block cipher class
class Cipher cipher => BlockCipher cipher where cbcEncrypt = cbcEncryptGeneric cbcDecrypt = cbcDecryptGeneric cfbEncrypt = cfbEncryptGeneric cfbDecrypt = cfbDecryptGeneric ctrCombine = ctrCombineGeneric xtsEncrypt = xtsEncryptGeneric xtsDecrypt = xtsDecryptGeneric aeadInit _ _ _ = Nothing

-- | Return the size of block required for this block cipher
blockSize :: BlockCipher cipher => cipher -> Int

-- | Encrypt blocks
--   
--   the input string need to be multiple of the block size
ecbEncrypt :: BlockCipher cipher => cipher -> ByteString -> ByteString

-- | Decrypt blocks
--   
--   the input string need to be multiple of the block size
ecbDecrypt :: BlockCipher cipher => cipher -> ByteString -> ByteString

-- | encrypt using the CBC mode.
--   
--   input need to be a multiple of the blocksize
cbcEncrypt :: BlockCipher cipher => cipher -> IV cipher -> ByteString -> ByteString

-- | decrypt using the CBC mode.
--   
--   input need to be a multiple of the blocksize
cbcDecrypt :: BlockCipher cipher => cipher -> IV cipher -> ByteString -> ByteString

-- | encrypt using the CFB mode.
--   
--   input need to be a multiple of the blocksize
cfbEncrypt :: BlockCipher cipher => cipher -> IV cipher -> ByteString -> ByteString

-- | decrypt using the CFB mode.
--   
--   input need to be a multiple of the blocksize
cfbDecrypt :: BlockCipher cipher => cipher -> IV cipher -> ByteString -> ByteString

-- | combine using the CTR mode.
--   
--   CTR mode produce a stream of randomized data that is combined (by XOR
--   operation) with the input stream.
--   
--   encryption and decryption are the same operation.
--   
--   input can be of any size
ctrCombine :: BlockCipher cipher => cipher -> IV cipher -> ByteString -> ByteString

-- | encrypt using the XTS mode.
--   
--   input need to be a multiple of the blocksize, and the cipher need to
--   process 128 bits block only
xtsEncrypt :: BlockCipher cipher => (cipher, cipher) -> IV cipher -> DataUnitOffset -> ByteString -> ByteString

-- | decrypt using the XTS mode.
--   
--   input need to be a multiple of the blocksize, and the cipher need to
--   process 128 bits block only
xtsDecrypt :: BlockCipher cipher => (cipher, cipher) -> IV cipher -> DataUnitOffset -> ByteString -> ByteString

-- | Initialize a new AEAD State
--   
--   When Nothing is returns, it means the mode is not handled.
aeadInit :: (BlockCipher cipher, Byteable iv) => AEADMode -> cipher -> iv -> Maybe (AEAD cipher)

-- | Symmetric stream cipher class
class Cipher cipher => StreamCipher cipher

-- | Combine using the stream cipher
streamCombine :: StreamCipher cipher => cipher -> ByteString -> (ByteString, cipher)

-- | Offset inside an XTS data unit, measured in block size.
type DataUnitOffset = Word32

-- | Different specifier for key size in bytes
data KeySizeSpecifier

-- | in the range [min,max]
KeySizeRange :: Int -> Int -> KeySizeSpecifier

-- | one of the specified values
KeySizeEnum :: [Int] -> KeySizeSpecifier

-- | a specific size
KeySizeFixed :: Int -> KeySizeSpecifier

-- | Possible Error that can be reported when initializating a key
data KeyError
KeyErrorTooSmall :: KeyError
KeyErrorTooBig :: KeyError
KeyErrorInvalid :: String -> KeyError

-- | Authenticated Encryption with Associated Data algorithms
data AEAD cipher
AEAD :: cipher -> (AEADState cipher) -> AEAD cipher

-- | Wrapper for any AEADState
data AEADState cipher
AEADState :: st -> AEADState cipher

-- | AEAD Mode
data AEADMode
AEAD_OCB :: AEADMode
AEAD_CCM :: AEADMode
AEAD_EAX :: AEADMode
AEAD_CWC :: AEADMode
AEAD_GCM :: AEADMode

-- | Class of AEAD Mode implementation
class BlockCipher cipher => AEADModeImpl cipher state
aeadStateAppendHeader :: AEADModeImpl cipher state => cipher -> state -> ByteString -> state
aeadStateEncrypt :: AEADModeImpl cipher state => cipher -> state -> ByteString -> (ByteString, state)
aeadStateDecrypt :: AEADModeImpl cipher state => cipher -> state -> ByteString -> (ByteString, state)
aeadStateFinalize :: AEADModeImpl cipher state => cipher -> state -> Int -> AuthTag

-- | Encrypt using CFB mode in 8 bit output
--   
--   Effectively turn a Block cipher in CFB mode into a Stream cipher
cfb8Encrypt :: BlockCipher a => a -> IV a -> ByteString -> ByteString

-- | Decrypt using CFB mode in 8 bit output
--   
--   Effectively turn a Block cipher in CFB mode into a Stream cipher
cfb8Decrypt :: BlockCipher a => a -> IV a -> ByteString -> ByteString

-- | Append associated data into the AEAD state
aeadAppendHeader :: BlockCipher a => AEAD a -> ByteString -> AEAD a

-- | Encrypt input and append into the AEAD state
aeadEncrypt :: BlockCipher a => AEAD a -> ByteString -> (ByteString, AEAD a)

-- | Decrypt input and append into the AEAD state
aeadDecrypt :: BlockCipher a => AEAD a -> ByteString -> (ByteString, AEAD a)

-- | Finalize the AEAD state and create an authentification tag
aeadFinalize :: BlockCipher a => AEAD a -> Int -> AuthTag

-- | Simple AEAD encryption
aeadSimpleEncrypt :: BlockCipher a => AEAD a -> ByteString -> ByteString -> Int -> (AuthTag, ByteString)

-- | Simple AEAD decryption
aeadSimpleDecrypt :: BlockCipher a => AEAD a -> ByteString -> ByteString -> AuthTag -> Maybe ByteString

-- | a Key parametrized by the cipher
data Key c

-- | Create a Key for a specified cipher
makeKey :: (ToSecureMem b, Cipher c) => b -> Either KeyError (Key c)

-- | an IV parametrized by the cipher
data IV c

-- | Create an IV for a specified block cipher
makeIV :: (Byteable b, BlockCipher c) => b -> Maybe (IV c)

-- | Create an IV that is effectively representing the number 0
nullIV :: BlockCipher c => IV c

-- | Increment an IV by a number.
--   
--   Assume the IV is in Big Endian format.
ivAdd :: BlockCipher c => IV c -> Int -> IV c

-- | Authentification Tag for AE cipher mode
newtype AuthTag
AuthTag :: ByteString -> AuthTag
