-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementations of the SHA suite of message digest functions
--   
--   This library implements the SHA suite of message digest functions,
--   according to NIST FIPS 180-2 (with the SHA-224 addendum), as well as
--   the SHA-based HMAC routines. The functions have been tested against
--   most of the NIST and RFC test vectors for the various functions. While
--   some attention has been paid to performance, these do not presently
--   reach the speed of well-tuned libraries, like OpenSSL.
@package SHA
@version 1.6.4.2


-- | Pure implementations of the SHA suite of hash functions. The
--   implementation is basically an unoptimized translation of FIPS 180-2
--   into Haskell. If you're looking for performance, you probably won't
--   find it here.
module Data.Digest.Pure.SHA

-- | An abstract datatype for digests.
data Digest t
data SHA1State
data SHA256State
data SHA512State

-- | Convert a digest to a string. The digest is rendered as fixed with
--   hexadecimal number.
showDigest :: Digest t -> String

-- | Convert a digest to an Integer.
integerDigest :: Digest t -> Integer

-- | Convert a digest to a ByteString.
bytestringDigest :: Digest t -> ByteString

-- | Compute the SHA-1 hash of the given ByteString. The output is
--   guaranteed to be exactly 160 bits, or 20 bytes, long. This is a good
--   default for programs that need a good, but not necessarily
--   hyper-secure, hash function.
sha1 :: ByteString -> Digest SHA1State

-- | Compute the SHA-224 hash of the given ByteString. Note that SHA-224
--   and SHA-384 differ only slightly from SHA-256 and SHA-512, and use
--   truncated versions of the resulting hashes. So using 224/384 may not,
--   in fact, save you very much ...
sha224 :: ByteString -> Digest SHA256State

-- | Compute the SHA-256 hash of the given ByteString. The output is
--   guaranteed to be exactly 256 bits, or 32 bytes, long. If your security
--   requirements are pretty serious, this is a good choice. For truly
--   significant security concerns, however, you might try one of the
--   bigger options.
sha256 :: ByteString -> Digest SHA256State

-- | Compute the SHA-384 hash of the given ByteString. Yup, you guessed it,
--   the output will be exactly 384 bits, or 48 bytes, long.
sha384 :: ByteString -> Digest SHA512State

-- | For those for whom only the biggest hashes will do, this computes the
--   SHA-512 hash of the given ByteString. The output will be 64 bytes, or
--   512 bits, long.
sha512 :: ByteString -> Digest SHA512State

-- | Similar to <a>sha1</a> but use an incremental interface. When the
--   decoder has been completely fed, <a>completeSha1Incremental</a> must
--   be used so it can finish successfully.
sha1Incremental :: Decoder SHA1State
completeSha1Incremental :: Decoder SHA1State -> Int -> Digest SHA1State

-- | Similar to <a>sha224</a> but use an incremental interface. When the
--   decoder has been completely fed, <a>completeSha224Incremental</a> must
--   be used so it can finish successfully.
sha224Incremental :: Decoder SHA256State
completeSha224Incremental :: Decoder SHA256State -> Int -> Digest SHA256State

-- | Similar to <a>sha256</a> but use an incremental interface. When the
--   decoder has been completely fed, <a>completeSha256Incremental</a> must
--   be used so it can finish successfully.
sha256Incremental :: Decoder SHA256State
completeSha256Incremental :: Decoder SHA256State -> Int -> Digest SHA256State

-- | Similar to <a>sha384</a> but use an incremental interface. When the
--   decoder has been completely fed, <a>completeSha384Incremental</a> must
--   be used so it can finish successfully.
sha384Incremental :: Decoder SHA512State
completeSha384Incremental :: Decoder SHA512State -> Int -> Digest SHA512State

-- | Similar to <a>sha512</a> but use an incremental interface. When the
--   decoder has been completely fed, <a>completeSha512Incremental</a> must
--   be used so it can finish successfully.
sha512Incremental :: Decoder SHA512State
completeSha512Incremental :: Decoder SHA512State -> Int -> Digest SHA512State

-- | Compute an HMAC using SHA-1.
hmacSha1 :: ByteString -> ByteString -> Digest SHA1State

-- | Compute an HMAC using SHA-224.
hmacSha224 :: ByteString -> ByteString -> Digest SHA256State

-- | Compute an HMAC using SHA-256.
hmacSha256 :: ByteString -> ByteString -> Digest SHA256State

-- | Compute an HMAC using SHA-384.
hmacSha384 :: ByteString -> ByteString -> Digest SHA512State

-- | Compute an HMAC using SHA-512.
hmacSha512 :: ByteString -> ByteString -> Digest SHA512State
toBigEndianSBS :: (Integral a, Bits a) => Int -> a -> ByteString
fromBigEndianSBS :: (Integral a, Bits a) => ByteString -> a
calc_k :: Word64 -> Word64 -> Word64 -> Word64
padSHA1 :: ByteString -> ByteString
padSHA512 :: ByteString -> ByteString
padSHA1Chunks :: Int -> [ByteString]
padSHA512Chunks :: Int -> [ByteString]
instance GHC.Classes.Ord (Data.Digest.Pure.SHA.Digest t)
instance GHC.Classes.Eq (Data.Digest.Pure.SHA.Digest t)
instance GHC.Show.Show (Data.Digest.Pure.SHA.Digest t)
instance Data.Binary.Class.Binary (Data.Digest.Pure.SHA.Digest Data.Digest.Pure.SHA.SHA1State)
instance Data.Binary.Class.Binary (Data.Digest.Pure.SHA.Digest Data.Digest.Pure.SHA.SHA256State)
instance Data.Binary.Class.Binary (Data.Digest.Pure.SHA.Digest Data.Digest.Pure.SHA.SHA512State)
instance Data.Binary.Class.Binary Data.Digest.Pure.SHA.SHA1State
instance Data.Binary.Class.Binary Data.Digest.Pure.SHA.SHA256State
instance Data.Binary.Class.Binary Data.Digest.Pure.SHA.SHA512State
