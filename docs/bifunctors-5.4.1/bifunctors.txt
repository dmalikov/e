-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bifunctors
--   
--   Bifunctors
@package bifunctors
@version 5.4.1


module Data.Bifoldable

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <tt>Bifunctor</tt> instance, it should satisfy:
--   
--   <pre>
--   'bifoldMap' f g ≡ 'bifold' . 'bimap' f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   'bifoldMap' f g . 'bimap' h i ≡ 'bifoldMap' (f . h) (g . i)
--   </pre>
class Bifoldable p where bifold = bifoldMap id id bifoldMap f g = bifoldr (mappend . f) (mappend . g) mempty bifoldr f g z t = appEndo (bifoldMap (Endo #. f) (Endo #. g) t) z bifoldl f g z t = appEndo (getDual (bifoldMap (Dual . Endo . flip f) (Dual . Endo . flip g) t)) z

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elments of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z .  toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | A variant of <a>bifoldr</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | A variant of <a>bifoldl</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <pre>
--   &gt;&gt;&gt; &gt; bifor_ ('a', "bc") print (print . reverse)
--   'a'
--   "cb"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | As <a>bimapM</a>, but ignores the results of the functions, merely
--   performing the "actions".
bimapM_ :: (Bifoldable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m ()

-- | As <a>bimapM_</a>, but with the structure as the primary argument.
biforM_ :: (Bifoldable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m ()

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
bimsum :: (Bifoldable t, MonadPlus m) => t (m a) (m a) -> m a

-- | As <a>bisequenceA</a>, but ignores the results of the actions.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
bisequence_ :: (Bifoldable t, Monad m) => t (m a) (m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Collects the list of elements of a structure, from left to right.
biList :: Bifoldable t => t a a -> [a]

-- | Test whether the structure is empty.
binull :: Bifoldable t => t a b -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
bilength :: Bifoldable t => t a b -> Int

-- | Does the element occur in the structure?
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The largest element of a non-empty structure.
bimaximum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The least element of a non-empty structure.
biminimum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The <a>bisum</a> function computes the sum of the numbers of a
--   structure.
bisum :: (Bifoldable t, Num a) => t a a -> a

-- | The <a>biproduct</a> function computes the product of the numbers of a
--   structure.
biproduct :: (Bifoldable t, Num a) => t a a -> a

-- | Reduces a structure of lists to the concatenation of those lists.
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
biand :: Bifoldable t => t Bool Bool -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
bior :: Bifoldable t => t Bool Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   appropriate predicate.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy the
--   appropriate predicate.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | <a>binotElem</a> is the negation of <a>bielem</a>.
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg
instance Data.Bifoldable.Bifoldable (,)
instance Data.Bifoldable.Bifoldable Data.Functor.Const.Const
instance Data.Bifoldable.Bifoldable Data.Functor.Constant.Constant
instance Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
instance Data.Bifoldable.Bifoldable ((,,) x)
instance Data.Bifoldable.Bifoldable ((,,,) x y)
instance Data.Bifoldable.Bifoldable ((,,,,) x y z)
instance Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
instance Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
instance Data.Bifoldable.Bifoldable Data.Tagged.Tagged
instance Data.Bifoldable.Bifoldable Data.Either.Either
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Bifoldable.Max a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Bifoldable.Min a)


module Data.Bitraversable

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t
--   . <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>bitraverse</a> <tt>Identity</tt>
--   <tt>Identity</tt> ≡ <tt>Identity</tt></tt></li>
--   <li><i><i>composition</i></i> <tt><tt>Compose</tt> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡ <a>traverse</a>
--   (<tt>Compose</tt> . <a>fmap</a> g1 . f1) (<tt>Compose</tt> .
--   <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <tt>Identity</tt> and composition functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity { runIdentity :: a }
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure = Identity
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure = Compose . pure . pure
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   Some simple examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <tt>runIdentity</tt> . <a>bitraverse</a> (<tt>Identity</tt> . f) (<tt>Identity</tt> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable t where bitraverse f g = bisequenceA . bimap f g

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the elements produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequenceA_</a>.
--   
--   <pre>
--   <a>bisequenceA</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | As <a>bisequenceA</a>, but uses evidence that <tt>m</tt> is a
--   <a>Monad</a> rather than an <a>Applicative</a>. For a version that
--   ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bimapM</a> <a>id</a> <a>id</a>
--   <a>bisequence</a> ≡ <a>unwrapMonad</a> . <a>bisequenceA</a> . <a>bimap</a> <a>WrapMonad</a> <a>WrapMonad</a>
--   </pre>
bisequence :: (Bitraversable t, Monad m) => t (m a) (m b) -> m (t a b)

-- | As <a>bitraverse</a>, but uses evidence that <tt>m</tt> is a
--   <a>Monad</a> rather than an <a>Applicative</a>. For a version that
--   ignores the results, see <a>bimapM_</a>.
--   
--   <pre>
--   <a>bimapM</a> f g ≡ <a>bisequence</a> . <a>bimap</a> f g
--   <a>bimapM</a> f g ≡ <a>unwrapMonad</a> . <a>bitraverse</a> (<a>WrapMonad</a> . f) (<a>WrapMonad</a> . g)
--   </pre>
bimapM :: (Bitraversable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m (t c d)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | <a>biforM</a> is <a>bimapM</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>biforM_</a>.
biforM :: (Bitraversable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m (t c d)

-- | The <a>bimapAccumL</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from left to
--   right, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The <a>bimapAccumR</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from right
--   to left, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
bifoldMapDefault :: (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg
instance Data.Bitraversable.Bitraversable (,)
instance Data.Bitraversable.Bitraversable ((,,) x)
instance Data.Bitraversable.Bitraversable ((,,,) x y)
instance Data.Bitraversable.Bitraversable ((,,,,) x y z)
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
instance Data.Bitraversable.Bitraversable Data.Either.Either
instance Data.Bitraversable.Bitraversable Data.Functor.Const.Const
instance Data.Bitraversable.Bitraversable Data.Functor.Constant.Constant
instance Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
instance Data.Bitraversable.Bitraversable Data.Tagged.Tagged
instance GHC.Base.Functor (Data.Bitraversable.StateL s)
instance GHC.Base.Applicative (Data.Bitraversable.StateL s)
instance GHC.Base.Functor (Data.Bitraversable.StateR s)
instance GHC.Base.Applicative (Data.Bitraversable.StateR s)
instance GHC.Base.Functor Data.Bitraversable.Id
instance GHC.Base.Applicative Data.Bitraversable.Id


-- | Functions to mechanically derive <a>Bifunctor</a>, <a>Bifoldable</a>,
--   or <a>Bitraversable</a> instances, or to splice their functions
--   directly into source code. You need to enable the
--   <tt>TemplateHaskell</tt> language extension in order to use this
--   module.
module Data.Bifunctor.TH

-- | Generates a <a>Bifunctor</a> instance declaration for the given data
--   type or data family instance.
deriveBifunctor :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bimap</tt>
--   (without requiring a <a>Bifunctor</a> instance).
makeBimap :: Name -> Q Exp

-- | Generates a <a>Bifoldable</a> instance declaration for the given data
--   type or data family instance.
deriveBifoldable :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bifold</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifold :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldMap</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldMap :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldr</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldr :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldl</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldl :: Name -> Q Exp

-- | Generates a <a>Bitraversable</a> instance declaration for the given
--   data type or data family instance.
deriveBitraversable :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bitraverse</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBitraverse :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequenceA</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequenceA :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bimapM</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBimapM :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequence</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequence :: Name -> Q Exp
instance GHC.Classes.Eq Data.Bifunctor.TH.BiFun

module Data.Bifunctor.Functor

-- | Using parametricity as an approximation of a natural transformation in
--   two arguments.
type (:->) p q = forall a b. p a b -> q a b
class BifunctorFunctor t
bifmap :: BifunctorFunctor t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorMonad t where bibind f = bijoin . bifmap f bijoin = bibind id
bireturn :: BifunctorMonad t => p :-> t p
bibind :: BifunctorMonad t => (p :-> t q) -> t p :-> t q
bijoin :: BifunctorMonad t => t (t p) :-> t p
biliftM :: BifunctorMonad t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorComonad t where biextend f = bifmap f . biduplicate biduplicate = biextend id
biextract :: BifunctorComonad t => t p :-> p
biextend :: BifunctorComonad t => (t p :-> q) -> t p :-> t q
biduplicate :: BifunctorComonad t => t p :-> t (t p)
biliftW :: BifunctorComonad t => (p :-> q) -> t p :-> t q

module Data.Bifunctor.Sum
data Sum p q a b
L2 :: (p a b) -> Sum p q a b
R2 :: (q a b) -> Sum p q a b
instance forall k (p :: k -> * -> *) (q :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Sum.Sum p q a)
instance forall k k1 (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Sum.Sum p q a b)
instance forall k k1 (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Read.Read (p a b), GHC.Read.Read (q a b)) => GHC.Read.Read (Data.Bifunctor.Sum.Sum p q a b)
instance forall k k1 (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Show.Show (p a b), GHC.Show.Show (q a b)) => GHC.Show.Show (Data.Bifunctor.Sum.Sum p q a b)
instance forall k k1 (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Ord (p a b), GHC.Classes.Ord (q a b)) => GHC.Classes.Ord (Data.Bifunctor.Sum.Sum p q a b)
instance forall k k1 (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Eq (p a b), GHC.Classes.Eq (q a b)) => GHC.Classes.Eq (Data.Bifunctor.Sum.Sum p q a b)
instance (Data.Bifunctor.Bifunctor p, Data.Bifunctor.Bifunctor q) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bifoldable.Bifoldable p, Data.Bifoldable.Bifoldable q) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bitraversable.Bitraversable p, Data.Bitraversable.Bitraversable q) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Sum.Sum p q)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Sum.Sum p)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Sum.Sum p)


module Data.Biapplicative
class Bifunctor p => Biapplicative p where a *>> b = bimap (const id) (const id) <<$>> a <<*>> b a <<* b = bimap const const <<$>> a <<*>> b
bipure :: Biapplicative p => a -> b -> p a b
(<<*>>) :: Biapplicative p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>*&gt;&gt;</a> b ≡ <a>bimap</a> (<a>const</a> <a>id</a>) (<a>const</a> <a>id</a>) <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(*>>) :: Biapplicative p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;&lt;*</a> b ≡ <a>bimap</a> <a>const</a> <a>const</a> <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(<<*) :: Biapplicative p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
infixl 4 <<$>>
(<<**>>) :: Biapplicative p => p a c -> p (a -> b) (c -> d) -> p b d
infixl 4 <<**>>

-- | Lift binary functions
biliftA2 :: Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
biliftA3 :: Biapplicative w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
instance Data.Biapplicative.Biapplicative (,)
instance Data.Biapplicative.Biapplicative Data.Semigroup.Arg
instance GHC.Base.Monoid x => Data.Biapplicative.Biapplicative ((,,) x)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y) => Data.Biapplicative.Biapplicative ((,,,) x y)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z) => Data.Biapplicative.Biapplicative ((,,,,) x y z)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w) => Data.Biapplicative.Biapplicative ((,,,,,) x y z w)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w, GHC.Base.Monoid v) => Data.Biapplicative.Biapplicative ((,,,,,,) x y z w v)
instance Data.Biapplicative.Biapplicative Data.Tagged.Tagged
instance Data.Biapplicative.Biapplicative Data.Functor.Const.Const


module Data.Bifunctor.Biff

-- | Compose two <a>Functor</a>s on the inside of a <a>Bifunctor</a>.
newtype Biff p f g a b
Biff :: p (f a) (g b) -> Biff p f g a b
[runBiff] :: Biff p f g a b -> p (f a) (g b)
instance forall k k1 (p :: k -> k1 -> *) k2 (f :: k2 -> k) k3 (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Generics.Generic (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (p :: k -> k1 -> *) k2 (f :: k2 -> k) k3 (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Read.Read (p (f a) (g b)) => GHC.Read.Read (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (p :: k -> k1 -> *) k2 (f :: k2 -> k) k3 (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Show.Show (p (f a) (g b)) => GHC.Show.Show (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (p :: k -> k1 -> *) k2 (f :: k2 -> k) k3 (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Ord (p (f a) (g b)) => GHC.Classes.Ord (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (p :: k -> k1 -> *) k2 (f :: k2 -> k) k3 (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Eq (p (f a) (g b)) => GHC.Classes.Eq (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (p :: k -> * -> *) (f :: k1 -> k) (a :: k1) (g :: GHC.Types.* -> *). GHC.Base.Functor (p (f a)) => GHC.Generics.Generic1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bifunctor.Bifunctor p, GHC.Base.Functor f, GHC.Base.Functor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bifunctor.Bifunctor p, GHC.Base.Functor g) => GHC.Base.Functor (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Biff.Biff p f g)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Clown

-- | Make a <a>Functor</a> over the first argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Clown f a b
Clown :: f a -> Clown f a b
[runClown] :: Clown f a b -> f a
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Clown.Clown f a)
instance forall k (f :: k -> *) (a :: k) k1 (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Clown.Clown f a b)
instance forall k (f :: k -> *) (a :: k) k1 (b :: k1). GHC.Read.Read (f a) => GHC.Read.Read (Data.Bifunctor.Clown.Clown f a b)
instance forall k (f :: k -> *) (a :: k) k1 (b :: k1). GHC.Show.Show (f a) => GHC.Show.Show (Data.Bifunctor.Clown.Clown f a b)
instance forall k (f :: k -> *) (a :: k) k1 (b :: k1). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Bifunctor.Clown.Clown f a b)
instance forall k (f :: k -> *) (a :: k) k1 (b :: k1). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Bifunctor.Clown.Clown f a b)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). GHC.Base.Functor (Data.Bifunctor.Clown.Clown f a)
instance GHC.Base.Applicative f => Data.Biapplicative.Biapplicative (Data.Bifunctor.Clown.Clown f)
instance Data.Foldable.Foldable f => Data.Bifoldable.Bifoldable (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). Data.Foldable.Foldable (Data.Bifunctor.Clown.Clown f a)
instance Data.Traversable.Traversable f => Data.Bitraversable.Bitraversable (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). Data.Traversable.Traversable (Data.Bifunctor.Clown.Clown f a)


module Data.Bifunctor.Fix

-- | Greatest fixpoint of a <a>Bifunctor</a> (a <a>Functor</a> over the
--   first argument with zipping).
newtype Fix p a
In :: p (Fix p a) a -> Fix p a
[out] :: Fix p a -> p (Fix p a) a
instance forall k (p :: * -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Classes.Eq (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Eq (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Classes.Ord (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Ord (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Show.Show (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Show.Show (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Read.Read (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Read.Read (Data.Bifunctor.Fix.Fix p a)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Fix.Fix p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Fix.Fix p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Fix.Fix p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Fix.Fix p)


module Data.Bifunctor.Flip

-- | Make a <a>Bifunctor</a> flipping the arguments of a <a>Bifunctor</a>.
newtype Flip p a b
Flip :: p b a -> Flip p a b
[runFlip] :: Flip p a b -> p b a
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Generics.Generic (Data.Bifunctor.Flip.Flip p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Read.Read (p b a) => GHC.Read.Read (Data.Bifunctor.Flip.Flip p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Show.Show (p b a) => GHC.Show.Show (Data.Bifunctor.Flip.Flip p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Classes.Ord (p b a) => GHC.Classes.Ord (Data.Bifunctor.Flip.Flip p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Classes.Eq (p b a) => GHC.Classes.Eq (Data.Bifunctor.Flip.Flip p a b)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Flip.Flip p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Flip.Flip p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Flip.Flip p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bifunctor.Functor.BifunctorFunctor Data.Bifunctor.Flip.Flip


module Data.Bifunctor.Join

-- | Make a <a>Functor</a> over both arguments of a <a>Bifunctor</a>.
newtype Join p a
Join :: p a a -> Join p a
[runJoin] :: Join p a -> p a a
instance forall k (p :: k -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Classes.Eq (p a a) => GHC.Classes.Eq (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Classes.Ord (p a a) => GHC.Classes.Ord (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Show.Show (p a a) => GHC.Show.Show (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Read.Read (p a a) => GHC.Read.Read (Data.Bifunctor.Join.Join p a)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Join.Join p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Join.Join p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Join.Join p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Join.Join p)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Joker

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Joker g a b
Joker :: g b -> Joker g a b
[runJoker] :: Joker g a b -> g b
instance forall (g :: * -> *) k (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Joker.Joker g a)
instance forall k (g :: k -> *) k1 (a :: k1) (b :: k). GHC.Generics.Generic (Data.Bifunctor.Joker.Joker g a b)
instance forall k (g :: k -> *) k1 (a :: k1) (b :: k). GHC.Read.Read (g b) => GHC.Read.Read (Data.Bifunctor.Joker.Joker g a b)
instance forall k (g :: k -> *) k1 (a :: k1) (b :: k). GHC.Show.Show (g b) => GHC.Show.Show (Data.Bifunctor.Joker.Joker g a b)
instance forall k (g :: k -> *) k1 (a :: k1) (b :: k). GHC.Classes.Ord (g b) => GHC.Classes.Ord (Data.Bifunctor.Joker.Joker g a b)
instance forall k (g :: k -> *) k1 (a :: k1) (b :: k). GHC.Classes.Eq (g b) => GHC.Classes.Eq (Data.Bifunctor.Joker.Joker g a b)
instance GHC.Base.Functor g => Data.Bifunctor.Bifunctor (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). GHC.Base.Functor g => GHC.Base.Functor (Data.Bifunctor.Joker.Joker g a)
instance GHC.Base.Applicative g => Data.Biapplicative.Biapplicative (Data.Bifunctor.Joker.Joker g)
instance Data.Foldable.Foldable g => Data.Bifoldable.Bifoldable (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Foldable.Foldable g => Data.Foldable.Foldable (Data.Bifunctor.Joker.Joker g a)
instance Data.Traversable.Traversable g => Data.Bitraversable.Bitraversable (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Traversable.Traversable g => Data.Traversable.Traversable (Data.Bifunctor.Joker.Joker g a)


-- | The product of two bifunctors.
module Data.Bifunctor.Product

-- | Form the product of two bifunctors
data Product f g a b
Pair :: (f a b) -> (g a b) -> Product f g a b
instance forall k (f :: k -> * -> *) (g :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Product.Product f g a)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Product.Product f g a b)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Read.Read (f a b), GHC.Read.Read (g a b)) => GHC.Read.Read (Data.Bifunctor.Product.Product f g a b)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Show.Show (f a b), GHC.Show.Show (g a b)) => GHC.Show.Show (Data.Bifunctor.Product.Product f g a b)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Ord (f a b), GHC.Classes.Ord (g a b)) => GHC.Classes.Ord (Data.Bifunctor.Product.Product f g a b)
instance forall k k1 (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Eq (f a b), GHC.Classes.Eq (g a b)) => GHC.Classes.Eq (Data.Bifunctor.Product.Product f g a b)
instance (Data.Bifunctor.Bifunctor f, Data.Bifunctor.Bifunctor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Product.Product f g)
instance (Data.Biapplicative.Biapplicative f, Data.Biapplicative.Biapplicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Product.Product f g)
instance (Data.Bifoldable.Bifoldable f, Data.Bifoldable.Bifoldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Product.Product f g)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Product.Product f g)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Product.Product p)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Product.Product p)


module Data.Bifunctor.Tannen

-- | Compose a <a>Functor</a> on the outside of a <a>Bifunctor</a>.
newtype Tannen f p a b
Tannen :: f (p a b) -> Tannen f p a b
[runTannen] :: Tannen f p a b -> f (p a b)
instance forall k (f :: k -> *) k1 k2 (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k (f :: k -> *) k1 k2 (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Read.Read (f (p a b)) => GHC.Read.Read (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k (f :: k -> *) k1 k2 (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Show.Show (f (p a b)) => GHC.Show.Show (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k (f :: k -> *) k1 k2 (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Classes.Ord (f (p a b)) => GHC.Classes.Ord (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k (f :: k -> *) k1 k2 (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Classes.Eq (f (p a b)) => GHC.Classes.Eq (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k (f :: * -> *) (p :: k -> GHC.Types.* -> *) (a :: k). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Bifunctor.Tannen.Tannen f p a)
instance GHC.Base.Functor f => Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, GHC.Base.Monad f) => Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Tannen.Tannen f)
instance Control.Comonad.Comonad f => Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => GHC.Base.Functor (Data.Bifunctor.Tannen.Tannen f p a)
instance (GHC.Base.Applicative f, Data.Biapplicative.Biapplicative p) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Foldable.Foldable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Traversable.Traversable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Tannen.Tannen f p)
instance forall k (f :: * -> *) (p :: k -> k -> *). (GHC.Base.Applicative f, Control.Category.Category p) => Control.Category.Category (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.Arrow p) => Control.Arrow.Arrow (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowChoice p) => Control.Arrow.ArrowChoice (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowLoop p) => Control.Arrow.ArrowLoop (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowZero p) => Control.Arrow.ArrowZero (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowPlus p) => Control.Arrow.ArrowPlus (Data.Bifunctor.Tannen.Tannen f p)


module Data.Bifunctor.Wrapped

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype WrappedBifunctor p a b
WrapBifunctor :: p a b -> WrappedBifunctor p a b
[unwrapBifunctor] :: WrappedBifunctor p a b -> p a b
instance forall k (p :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Read.Read (p a b) => GHC.Read.Read (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Show.Show (p a b) => GHC.Show.Show (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Classes.Ord (p a b) => GHC.Classes.Ord (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Classes.Eq (p a b) => GHC.Classes.Eq (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Wrapped.WrappedBifunctor p)
