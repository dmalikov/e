-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast AES cipher implementation with advanced mode of operations
--   
--   Fast AES cipher implementation with advanced mode of operations.
--   
--   The modes of operations available are ECB (Electronic code book), CBC
--   (Cipher block chaining), CTR (Counter), XTS (XEX with ciphertext
--   stealing), GCM (Galois Counter Mode).
--   
--   The AES implementation uses AES-NI when available (on x86 and x86-64
--   architecture), but fallback gracefully to a software C implementation.
--   
--   The software implementation uses S-Boxes, which might suffer for cache
--   timing issues. However do notes that most other known software
--   implementations, including very popular one (openssl, gnutls) also
--   uses similar implementation. If it matters for your case, you should
--   make sure you have AES-NI available, or you'll need to use a different
--   implementation.
@package cipher-aes
@version 0.2.11


module Crypto.Cipher.AES

-- | AES Context (pre-processed key)
data AES

-- | AES with 128 bit key
data AES128

-- | AES with 192 bit key
data AES192

-- | AES with 256 bit key
data AES256

-- | AES IV is always 16 bytes
data AESIV

-- | convert a bytestring to an AESIV
aesIV_ :: ByteString -> AESIV

-- | AESGCM State
data AESGCM

-- | Initialize a new context with a key
--   
--   Key need to be of length 16, 24 or 32 bytes. any other values will
--   cause undefined behavior
initAES :: Byteable b => b -> AES

-- | <i>Deprecated: use initAES</i>
initKey :: Byteable b => b -> AES

-- | generate a counter mode pad. this is generally xor-ed to an input to
--   make the standard counter mode block operations.
--   
--   if the length requested is not a multiple of the block cipher size,
--   more data will be returned, so that the returned bytestring is a
--   multiple of the block cipher size.
genCTR :: Byteable iv => AES -> iv -> Int -> ByteString

-- | generate a counter mode pad. this is generally xor-ed to an input to
--   make the standard counter mode block operations.
--   
--   if the length requested is not a multiple of the block cipher size,
--   more data will be returned, so that the returned bytestring is a
--   multiple of the block cipher size.
--   
--   Similiar to <a>genCTR</a> but also return the next IV for continuation
genCounter :: AES -> AESIV -> Int -> (ByteString, AESIV)

-- | encrypt using Electronic Code Book (ECB)
encryptECB :: AES -> ByteString -> ByteString

-- | encrypt using Cipher Block Chaining (CBC)
encryptCBC :: Byteable iv => AES -> iv -> ByteString -> ByteString

-- | encrypt using Counter mode (CTR)
--   
--   in CTR mode encryption and decryption is the same operation.
encryptCTR :: Byteable iv => AES -> iv -> ByteString -> ByteString

-- | encrypt using XTS
--   
--   the first key is the normal block encryption key the second key is
--   used for the initial block tweak
encryptXTS :: Byteable iv => (AES, AES) -> iv -> Word32 -> ByteString -> ByteString

-- | encrypt using Galois counter mode (GCM) return the encrypted
--   bytestring and the tag associated
--   
--   note: encrypted data is identical to CTR mode in GCM, however a tag is
--   also computed.
encryptGCM :: Byteable iv => AES -> iv -> ByteString -> ByteString -> (ByteString, AuthTag)

-- | encrypt using OCB v3 return the encrypted bytestring and the tag
--   associated
encryptOCB :: Byteable iv => AES -> iv -> ByteString -> ByteString -> (ByteString, AuthTag)

-- | decrypt using Electronic Code Book (ECB)
decryptECB :: AES -> ByteString -> ByteString

-- | decrypt using Cipher block chaining (CBC)
decryptCBC :: Byteable iv => AES -> iv -> ByteString -> ByteString

-- | decrypt using Counter mode (CTR).
--   
--   in CTR mode encryption and decryption is the same operation.
decryptCTR :: Byteable iv => AES -> iv -> ByteString -> ByteString

-- | decrypt using XTS
decryptXTS :: Byteable iv => (AES, AES) -> iv -> Word32 -> ByteString -> ByteString

-- | decrypt using Galois Counter Mode (GCM)
decryptGCM :: Byteable iv => AES -> iv -> ByteString -> ByteString -> (ByteString, AuthTag)

-- | decrypt using Offset Codebook Mode (OCB)
decryptOCB :: Byteable iv => AES -> iv -> ByteString -> ByteString -> (ByteString, AuthTag)
instance Data.Byteable.Byteable Crypto.Cipher.AES.AESIV
instance GHC.Classes.Eq Crypto.Cipher.AES.AESIV
instance GHC.Show.Show Crypto.Cipher.AES.AESIV
instance Crypto.Cipher.Types.Base.Cipher Crypto.Cipher.AES.AES
instance Crypto.Cipher.Types.Base.Cipher Crypto.Cipher.AES.AES128
instance Crypto.Cipher.Types.Base.Cipher Crypto.Cipher.AES.AES192
instance Crypto.Cipher.Types.Base.Cipher Crypto.Cipher.AES.AES256
instance Crypto.Cipher.Types.Block.BlockCipher Crypto.Cipher.AES.AES
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES Crypto.Cipher.AES.AESGCM
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES Crypto.Cipher.AES.AESOCB
instance Crypto.Cipher.Types.Block.BlockCipher Crypto.Cipher.AES.AES128
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES128 Crypto.Cipher.AES.AESGCM
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES128 Crypto.Cipher.AES.AESOCB
instance Crypto.Cipher.Types.Block.BlockCipher Crypto.Cipher.AES.AES192
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES192 Crypto.Cipher.AES.AESGCM
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES192 Crypto.Cipher.AES.AESOCB
instance Crypto.Cipher.Types.Block.BlockCipher Crypto.Cipher.AES.AES256
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES256 Crypto.Cipher.AES.AESGCM
instance Crypto.Cipher.Types.Block.AEADModeImpl Crypto.Cipher.AES.AES256 Crypto.Cipher.AES.AESOCB
